var util = require('util');
var EventEmitter = require('events').EventEmitter;

function Work(data, ResByCount) {
    this.data = data;
    this.ResponseByteCount = ResByCount;
}

function ModbusRtuMaster(port, baud, interval, timeout) {
    EventEmitter.call(this);    
    var com = require("./serialport");
    this.crc = require("./crc");
    
    this.interval = interval;
    this.timeout = timeout;
    
    this.MonitorAddress = [];
    this.Works = [];
    this.ControlWorks = [];
    this.response = [];
    this.Bits = {};
    this.Words = {};
    this.w = null;
    
    var inst = this;
    
    this.recvstate = false;
    this.writestate = false;
    this.writetime;
    this.ser = new com.SerialPort(port, { baudrate: baud });
    this.ser.on('open', function () { });
    this.ser.on('error', function (err) { console.log("err"); });
    this.ser.on('data', function (data) {
        for (i = 0; i < data.length; i++) inst.response.push(data[i]);
        
        if (inst.w != null) {
            var slave = inst.w.data[0];
            var func = inst.w.data[1];
            var startaddr = inst.w.data[2] << 8 | inst.w.data[8];
            if (inst.response.length == inst.w.ResponseByteCount) {
                var datacr = [];
                for (i = 0; i < inst.response.length - 2; i++) datacr.push(inst.response[i]);
                
                var vcrc = inst.crc.crc16modbus(datacr);
                if (((vcrc & 0xFF00) >> 8) == inst.response[inst.response.length - 1] && (vcrc & 0xFF) == inst.response[inst.response.length - 2]) {
                    switch (func) {
                        case 1:
                        case 2:
                            {
                                var changed = false;
                                var byteCount = inst.response[2];
                                for (i = 0; i < byteCount; i++) {
                                    for (j = 0; j < 8; j++) {
                                        var a = inst.Bits[slave][startaddr + ((i * 8) + j)];
                                        var val = (inst.response[3 + i] & Math.pow(2, j)) == Math.pow(2, j); 
                                        if (a != val) {
                                            inst.Bits[slave][startaddr + ((i * 8) + j)] = val;
                                            changed = true;
                                        }
                                    }
                                }
                                if (changed) inst.emit("valuechanged");
                            }                            
                            break;
                        case 3:
                        case 4:
                            {
                                var changed = false;
                                var byteCount = inst.response[2];
                                
                                for (i = 0; i < byteCount / 2; i++) {
                                    var a = inst.Words[slave][startaddr + i]
                                    var val = inst.response[3 + (i * 2)] << 8 | inst.response[4 + (i * 2)];
                                    if (a != val) {
                                        inst.Words[slave][startaddr + i] = val;
                                        changed = true;
                                    }
                                }

                                if (changed) inst.emit("valuechanged");
                            }
                            break;
                    }
                }
                inst.recvstate = true;
                inst.writestate = false;
                
            }
        }
    });
    
    setTimeout(function () { inst.proc(); }, this.interval);
}

util.inherits(ModbusRtuMaster, EventEmitter); 

ModbusRtuMaster.prototype.proc = function () {
    
    if (!this.writestate) this.write();
    var now = new Date();
    if (now.getTime() - this.writetime > this.timeout) this.writestate = false;
    delete now;
    var inst = this;
    setTimeout(function () { inst.proc(); }, inst.interval);
};

ModbusRtuMaster.prototype.write = function () {
    this.w = null;
    if (this.ControlWorks.length > 0) this.w = this.ControlWorks.pop();
    else this.w = this.Works.pop();
    
    if (this.w != null) {
        this.response.length = 0;
        this.writestate = true;
        var now = new Date();
        this.writetime = now.getTime();
        delete now;
        this.ser.write(this.w.data, function (err, result) { });
    }
    
    if (this.Works.length == 0)
        for (i = 0; i < this.MonitorAddress.length; i++)
            this.Works.push(this.MonitorAddress[i]);
};

ModbusRtuMaster.prototype.addBitMonitor = function (slave, startAddr, length) {
    var data = new Buffer(8);
    var nResCount;
    var vcrc;
    data[0] = slave;
    data[1] = 0x1;
    data[2] = (startAddr & 0xFF00) >> 8;
    data[3] = (startAddr & 0xFF);
    data[4] = (length & 0xFF00) >> 8;
    data[5] = (length & 0xFF);
    
    vcrc = this.crc.crc16modbus([data [0], data [1], data [2], data [3], data [4], data [5]]);
    data[6] = (vcrc & 0xFF);
    data[7] = (vcrc & 0xFF00) >> 8;
    
    nResCount = length / 8;
    if (length % 8 != 0) nResCount++;
    
    if (this.Bits[slave] == null) this.Bits[slave] = {};
    for (i = 0; i < length; i++) this.Bits[slave][startAddr + i] = false;
    
    this.MonitorAddress.push(new Work(data, nResCount + 5));
};

ModbusRtuMaster.prototype.addWordMonitor = function (slave, startAddr, length) {
    var data = new Buffer(8);
    var nResCount;
    var vcrc;
    data[0] = slave;
    data[1] = 0x3;
    data[2] = (startAddr & 0xFF00) >> 8;
    data[3] = (startAddr & 0xFF);
    data[4] = (length & 0xFF00) >> 8;
    data[5] = (length & 0xFF);
    
    vcrc = this.crc.crc16modbus([data [0], data [1], data [2], data [3], data [4], data [5]]);
    data[6] = (vcrc & 0xFF);
    data[7] = (vcrc & 0xFF00) >> 8;
    
    if (this.Words[slave] == null) this.Words[slave] = {};
    for (i = 0; i < length; i++) this.Words[slave][startAddr + i] = 0;
    
    this.MonitorAddress.push(new Work(data, length * 2 + 5));
};

ModbusRtuMaster.prototype.setBit = function (slave, startAddr, value) {
    var data = new Buffer(8);
    var nval;
    var vcrc;

	console.log(value ? "t":"f");

	if(value) nval = 0xFF00;
	else nval= 0x0000;
	


    data[0] = slave;
    data[1] = 0x5;
    data[2] = (startAddr & 0xFF00) >> 8;
    data[3] = (startAddr & 0xFF);
    data[4] = (nval & 0xFF00) >> 8;
    data[5] = (nval & 0xFF);
    
    vcrc = this.crc.crc16modbus([data [0], data [1], data [2], data [3], data [4], data [5]]);
    data[6] = (vcrc & 0xFF);
    data[7] = (vcrc & 0xFF00) >> 8;

    this.ControlWorks.push(new Work(data, 8));
};

ModbusRtuMaster.prototype.setWord = function (slave, startAddr, value) {
    var data = new Buffer(8);
    var vcrc;
    
    data[0] = slave;
    data[1] = 0x6;
    data[2] = (startAddr & 0xFF00) >> 8;
    data[3] = (startAddr & 0xFF);
    data[4] = (value & 0xFF00) >> 8;
    data[5] = (value & 0xFF);
    
    vcrc = this.crc.crc16modbus([data [0], data [1], data [2], data [3], data [4], data [5]]);
    data[6] = (vcrc & 0xFF);
    data[7] = (vcrc & 0xFF00) >> 8;
    
    this.ControlWorks.push(new Work(data, 8));
};

ModbusRtuMaster.prototype.setBits = function (slave, startAddr, values) {
    var length = values.length / 8;
    length += (values.length % 8 == 0) ? 0 : 1;

    var data = new Buffer(9 + length);
    var buf = [];
    var vcrc;
    
    data[0] = slave;
    data[1] = 0x0F;
    data[2] = (startAddr & 0xFF00) >> 8;
    data[3] = (startAddr & 0xFF);
    data[4] = (values.length & 0xFF00) >> 8;
    data[5] = (values.length & 0xFF);
    data[6] = length;
    
    for (i = 0; i < length; i++) {
        var val = 0;
        var nTemp = 0;
        var n = values.length;
        for (j = (i * 8); j < n && j < (i * 8) + 8; j++)
        {
            if (values[j])
                val |= Math.pow(2, nTemp);
            nTemp++;
        }
        data[7 + i] = val;
    }
    
    for (i = 0; i < data.length - 2; i++) buf.push(data[i]);
    vcrc = this.crc.crc16modbus(buf);
    data[data.length - 2] = (vcrc & 0xFF);
    data[data.length - 1] = (vcrc & 0xFF00) >> 8;
    this.ControlWorks.push(new Work(data, 8));
};

ModbusRtuMaster.prototype.setWords = function (slave, startAddr, values) {
    
    var data = new Buffer(9 + (values.length * 2));
    var buf = [];
    var vcrc;
    
    data[0] = slave;
    data[1] = 0x10;
    data[2] = (startAddr & 0xFF00) >> 8;
    data[3] = (startAddr & 0xFF);
    data[4] = (values.length & 0xFF00) >> 8;
    data[5] = (values.length & 0xFF);
    data[6] = values.length * 2;
    
    var n = values.length;
    for (i = 0; i < n; i++) {
        data[7 + (i * 2)] = (values[i] & 0xFF00) >> 8;
        data[8 + (i * 2)] = (values[i] & 0xFF);
    }
    for (i = 0; i < data.length - 2; i++) buf.push(data[i]);
    vcrc = this.crc.crc16modbus(buf);
    data[data.length - 2] = (vcrc & 0xFF);
    data[data.length - 1] = (vcrc & 0xFF00) >> 8;
    this.ControlWorks.push(new Work(data, 8));
};

module.exports = ModbusRtuMaster;
